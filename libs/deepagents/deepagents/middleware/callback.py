"""Middleware for LLM-driven callback mechanism.

This middleware provides a callback tool that the LLM can use to send intermediate
and final results to a callback URL. The LLM decides when to send callbacks.
"""

import json
from collections.abc import Awaitable, Callable
from datetime import datetime
from typing import Any, Annotated, NotRequired, TypedDict, cast

from langchain.agents.middleware.types import (
    AgentMiddleware,
    AgentState,
    ModelRequest,
    ModelResponse,
)
from langchain.tools import InjectedToolCallId, ToolRuntime
from langchain_core.messages import ToolMessage
from langchain_core.tools import StructuredTool
from langgraph.runtime import Runtime
from langgraph.types import Command


class CallbackState(AgentState):
    """State for callback configuration."""

    callback_url: NotRequired[str | None]
    """The callback URL to POST updates to."""

    session_id: NotRequired[str | None]
    """The session ID (thread_id) for this conversation."""

    interrupted: NotRequired[bool]
    """Flag indicating if execution was interrupted via callback response."""


CALLBACK_TOOL_DESCRIPTION = """Send a callback to deliver intermediate or final results to the user.

Use this tool when you have:
- An intermediate result or conclusion that should be communicated to the user
- A final conclusion or answer
- An artifact generated by applying a skill (e.g., a document, analysis, or output)
- A list of artifacts that have been uploaded

The callback will be sent to the configured callback URL with the session ID, your message/status/artifacts, and a timestamp.

Args:
    message: The actual message content to send to the user (for assistant responses).
        Use this when you have substantive content to deliver.
    status: A status update or progress notification (for non-message updates like tool calls,
        processing states, etc.). Use this for status updates that are not direct user messages.
    artifacts: If True, sends the latest list of all artifacts that have been uploaded.
        Use this to notify the front end about uploaded deliverables (typically HTML files).

Note: You should use EITHER 'message' OR 'status' OR 'artifacts' (or any combination).
Use 'message' for actual content, 'status' for progress/state updates, and 'artifacts' to send
the current list of uploaded artifacts.
"""


CALLBACK_SYSTEM_PROMPT = """## Callback Mechanism

You have access to a `callback` tool that allows you to send intermediate and final results to the user via a callback URL.

**When to use callbacks:**

1. **Intermediate results**: When you have meaningful intermediate findings or conclusions that should be shared with the user
   - Example: After completing a significant analysis step
   - Example: When you've identified key information that answers part of the user's question

2. **Intermediate conclusions**: When you reach a milestone or checkpoint in your work
   - Example: After successfully applying a skill and generating an artifact
   - Example: When you complete a major phase of work

3. **Final conclusions**: When you have the complete answer or result
   - Example: After fully answering the user's question
   - Example: After completing all requested work

4. **Artifacts**: When you generate deliverables (documents, files, analysis results, etc.)
   - Example: After creating a document using write_file
   - Example: After generating a comprehensive analysis or report

**How to use the callback tool:**

- Use the `message` parameter for actual content you want to deliver to the user
- Use the `status` parameter for progress updates, tool call notifications, or processing states
- Use the `artifacts` parameter (set to True) to send the latest list of all uploaded artifacts
- Use callbacks strategically to keep the user informed of progress without overwhelming them with every minor step
- For final responses, always send a callback with the complete message before concluding
- After uploading artifacts, use `artifacts=True` to notify the front end about the updated artifact list

**Interruption handling:**

- The callback URL may respond with an interruption signal (`{"action": "interrupt"}`)
- If you receive an interruption signal, you will be given an opportunity to wrap up your work
- When interrupted, provide a summary of what has been completed and any partial results or findings
- Be concise in your wrap-up message, focusing on the most important completed work"""


def _get_callback_tool() -> StructuredTool:  # noqa: PLR0915
    """Create the callback tool."""
    
    def sync_callback(
        message: Annotated[
            str | None,
            "The actual message content to send to the user (for assistant responses).",
        ] = None,
        status: Annotated[
            str | None,
            "A status update or progress notification (for non-message updates).",
        ] = None,
        artifacts: Annotated[
            bool,
            "If True, sends the latest list of all artifacts that have been uploaded.",
        ] = False,
        runtime: ToolRuntime[None, CallbackState] = None,  # type: ignore[assignment]
        tool_call_id: Annotated[str, InjectedToolCallId] = "",
    ) -> Command:
        """Send a callback to deliver results to the user.
        
        Args:
            message: The actual message content (use for assistant responses).
            status: A status update (use for progress/state updates).
            artifacts: If True, sends the latest list of all artifacts.
            runtime: Runtime context for accessing state (automatically injected).
            tool_call_id: Injected tool call ID.
        
        Returns:
            Command that triggers the callback and returns a tool message.
        """
        # Get callback_url and session_id from state
        state = runtime.state if runtime else {}
        callback_url = state.get("callback_url")
        session_id = state.get("session_id")
        
        if not callback_url:
            return Command(
                update={
                    "messages": [
                        ToolMessage(
                            content="Callback URL not configured. Cannot send callback.",
                            tool_call_id=tool_call_id,
                        )
                    ]
                }
            )
        
        if not message and not status and not artifacts:
            return Command(
                update={
                    "messages": [
                        ToolMessage(
                            content="Either 'message', 'status', or 'artifacts' must be provided for callback.",
                            tool_call_id=tool_call_id,
                        )
                    ]
                }
            )
        
        # Generate timestamp
        timestamp = datetime.utcnow().isoformat() + "Z"
        
        # Build callback payload
        callback_payload: dict[str, Any] = {
            "session_id": session_id,
            "timestamp": timestamp,
        }
        
        # Handle artifacts: read from state and send
        # Artifacts takes precedence if requested
        artifacts_list: list[Any] | None = None
        if artifacts:
            artifacts_list = state.get("artifacts", [])
            callback_payload["type"] = "artifacts"
            callback_payload["artifacts"] = artifacts_list
        elif message:
            callback_payload["type"] = "message"
            callback_payload["message"] = message
        elif status:
            callback_payload["type"] = "status"
            callback_payload["status"] = status
        
        # Invoke callback and wait for response to check for interruption
        interrupted = False
        import logging
        logger = logging.getLogger(__name__)
        
        try:
            # Log callback request
            logger.info(
                "[CallbackMiddleware] Sending callback request: url=%s, type=%s, session_id=%s",
                callback_url,
                callback_payload.get("type", "unknown"),
                callback_payload.get("session_id"),
            )
            logger.debug(
                "[CallbackMiddleware] Callback request payload: %s",
                callback_payload,
            )
            
            import requests
            response = requests.post(
                callback_url,
                json=callback_payload,
                headers={"Content-Type": "application/json"},
                timeout=30,
            )
            
            # Log callback response - always print full response data
            response_text = response.text if hasattr(response, "text") else "N/A"
            logger.info(
                "[CallbackMiddleware] Callback response received: status_code=%d, url=%s",
                response.status_code,
                callback_url,
            )
            logger.info(
                "[CallbackMiddleware] Callback response text (full): %s",
                response_text,
            )
            
            # Check response for interruption signal
            if response.status_code == 200:
                try:
                    response_data = response.json()
                    logger.info(
                        "[CallbackMiddleware] Callback response data (parsed JSON): %s",
                        response_data,
                    )
                    logger.info(
                        "[CallbackMiddleware] Callback response data type: %s, keys: %s",
                        type(response_data).__name__,
                        list(response_data.keys()) if isinstance(response_data, dict) else "N/A",
                    )
                    if isinstance(response_data, dict) and response_data.get("action") == "interrupt":
                        interrupted = True
                        logger.info(
                            "[CallbackMiddleware] Interruption signal received from callback URL: url=%s, response_data=%s",
                            callback_url,
                            response_data,
                        )
                    else:
                        logger.info(
                            "[CallbackMiddleware] No interruption signal found in response. action field value: %s",
                            response_data.get("action") if isinstance(response_data, dict) else "N/A",
                        )
                except (ValueError, json.JSONDecodeError) as json_err:
                    # Response is not JSON - log the error and full text
                    logger.warning(
                        "[CallbackMiddleware] Callback response is not valid JSON: error=%s, response_text=%s",
                        str(json_err),
                        response_text,
                    )
                except Exception as parse_err:  # noqa: BLE001
                    logger.warning(
                        "[CallbackMiddleware] Error parsing callback response: error=%s, response_text=%s",
                        str(parse_err),
                        response_text,
                    )
            else:
                logger.warning(
                    "[CallbackMiddleware] Callback response non-200 status: status_code=%d, url=%s, response_text=%s",
                    response.status_code,
                    callback_url,
                    response_text,
                )
        except Exception as e:  # noqa: BLE001
            # Log error but don't fail the tool call
            logger.warning("Failed to invoke callback URL %s: %s", callback_url, str(e))
            return Command(
                update={
                    "messages": [
                        ToolMessage(
                            content=f"Callback failed: {str(e)}",
                            tool_call_id=tool_call_id,
                        )
                    ]
                }
            )
        
        # Prepare state update
        state_update: dict[str, Any] = {}
        if interrupted:
            state_update["interrupted"] = True
        
        # Return success message
        if artifacts and artifacts_list is not None:
            callback_type = "artifacts"
            callback_value = f"{len(artifacts_list)} artifact(s)"
        elif message:
            callback_type = "message"
            callback_value = message[:100] + "..." if len(message) > 100 else message
        else:
            callback_type = "status"
            callback_value = status[:100] + "..." if status and len(status) > 100 else (status or "")
        
        tool_message_content = f"Callback sent ({callback_type}): {callback_value}"
        if interrupted:
            tool_message_content += " [Interruption signal received]"
        
        # Log return data
        return_data = {
            **state_update,
            "messages": [tool_message_content],
        }
        logger.info(
            "[CallbackMiddleware] Callback tool returning: interrupted=%s, message=%s",
            interrupted,
            tool_message_content[:100] + "..." if len(tool_message_content) > 100 else tool_message_content,
        )
        logger.debug(
            "[CallbackMiddleware] Callback tool return data: %s",
            return_data,
        )
        
        return Command(
            update={
                **state_update,
                "messages": [
                    ToolMessage(
                        content=tool_message_content,
                        tool_call_id=tool_call_id,
                    )
                ]
            }
        )
    
    async def async_callback(
        message: Annotated[
            str | None,
            "The actual message content to send to the user (for assistant responses).",
        ] = None,
        status: Annotated[
            str | None,
            "A status update or progress notification (for non-message updates).",
        ] = None,
        artifacts: Annotated[
            bool,
            "If True, sends the latest list of all artifacts that have been uploaded.",
        ] = False,
        runtime: ToolRuntime[None, CallbackState] = None,  # type: ignore[assignment]
        tool_call_id: Annotated[str, InjectedToolCallId] = "",
    ) -> Command:
        """Async version of callback tool."""
        # Same implementation as sync version
        return sync_callback(message, status, artifacts, runtime, tool_call_id)
    
    return StructuredTool.from_function(
        func=sync_callback,
        coroutine=async_callback,
        name="callback",
        description=CALLBACK_TOOL_DESCRIPTION,
    )


class CallbackMiddleware(AgentMiddleware):
    """Middleware for LLM-driven callback mechanism.
    
    This middleware:
    1. Stores callback_url and session_id (thread_id) in agent state
    2. Provides a callback tool that the LLM can call to send updates
    3. Adds system prompt instructions about when and how to use callbacks
    
    Example:
        ```python
        from deepagents.middleware.callback import CallbackMiddleware
        
        agent = create_agent(
            model="anthropic:claude-sonnet-4-20250514",
            middleware=[CallbackMiddleware()],
        )
        ```
    """
    
    state_schema = CallbackState
    
    def __init__(self) -> None:
        """Initialize the CallbackMiddleware."""
        self.tools = [_get_callback_tool()]
    
    def before_agent(
        self,
        state: CallbackState,
        runtime: Runtime,
    ) -> dict[str, Any] | None:
        """Initialize callback state from runtime config and initial state.
        
        Args:
            state: Current agent state (may already have callback_url from initial_state).
            runtime: Runtime context.
        
        Returns:
            Updated state with session_id (thread_id) if not present.
            Note: callback_url is expected to be set in initial_state by the caller.
        """
        updates: dict[str, Any] = {}
        
        # Extract thread_id from config and set as session_id
        config = runtime.config if hasattr(runtime, "config") else {}
        configurable = config.get("configurable", {})
        thread_id = configurable.get("thread_id")
        
        if thread_id and "session_id" not in state:
            updates["session_id"] = thread_id
        
        # callback_url should be set in initial_state when invoking the agent
        # We preserve it if it exists, but don't set it here if missing (let caller handle it)
        
        return updates if updates else None
    
    def wrap_model_call(
        self,
        request: ModelRequest,
        handler: Callable[[ModelRequest], ModelResponse],
    ) -> ModelResponse:
        """Inject callback instructions into the system prompt.
        
        This runs on every model call to ensure callback guidance is always available.
        Only adds instructions if callback_url is configured.
        
        Args:
            request: The model request being processed.
            handler: The handler function to call with the modified request.
        
        Returns:
            The model response from the handler.
        """
        # Check if callback_url is configured
        state = cast(CallbackState, request.state)
        callback_url = state.get("callback_url")
        
        # Only add system prompt if callback_url is configured
        if callback_url:
            system_prompt = request.system_prompt + "\n\n" + CALLBACK_SYSTEM_PROMPT if request.system_prompt else CALLBACK_SYSTEM_PROMPT
            return handler(request.override(system_prompt=system_prompt))
        
        return handler(request)
    
    async def awrap_model_call(
        self,
        request: ModelRequest,
        handler: Callable[[ModelRequest], Awaitable[ModelResponse]],
    ) -> ModelResponse:
        """Async version of wrap_model_call.
        
        Args:
            request: The model request being processed.
            handler: The handler function to call with the modified request.
        
        Returns:
            The model response from the handler.
        """
        state = cast(CallbackState, request.state)
        callback_url = state.get("callback_url")
        
        if callback_url:
            system_prompt = request.system_prompt + "\n\n" + CALLBACK_SYSTEM_PROMPT if request.system_prompt else CALLBACK_SYSTEM_PROMPT
            return await handler(request.override(system_prompt=system_prompt))
        
        return await handler(request)

